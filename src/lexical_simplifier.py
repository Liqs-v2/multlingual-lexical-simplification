import abc
import warnings
from abc import ABCMeta
from typing import List


# DISCLAIMER: This file was authored in an IDE with Github Copilot enabled.


class LexicalSimplifier(metaclass=ABCMeta):
    """
    An abstract base class for a lexical simplification. Implements a basic initializer and functions for
    setting the model and pattern for the simplifier. The main function to be implemented by subclasses is
    get_substitutions_for, which should return a list of possible substitutions for a given complex word.

    Attributes:
        model: The model used for generating substitutions.
        tokenizer: The tokenizer used for tokenizing the input sentence. Must be the model tokenizer.
        pattern: The format string used to dynamically build prompts for generating substitutions. In the simplest
            case this could be a string with one placeholder, into which the input sentence with the masked complex
            word is inserted (eg. for a BERT model).
        exemplars: A list of exemplars used for in-context learning. If provided, these will be prepended to the every
            prompt.
        mask_token: The token used to mask the complex word in the input sentence. Defaults to '[MASK]'.
    """
    model = None
    tokenizer = None
    pattern: str = None
    exemplars = None  # Duck-typing
    mask_token = '[MASK]'

    def __init__(self, model, tokenizer, mask_token, pattern=None, exemplars=None):
        if model is None:
            warnings.warn("Please initialize the model for this LexicalSimplifier. Only exception if for the GPT LexicalSimplifier.")

        if tokenizer is None:
            warnings.warn("Please initialize the tokenizer for this LexicalSimplifier. Only exception if for the GPT LexicalSimplifier.")
            
        if pattern is None or pattern == "":
            warnings.warn("No pattern provided, please use specify one or set it via the BenchmarkSuite!")

        if exemplars is None or len(exemplars) == 0:
            warnings.warn("No exemplars provided. This can cause problems, especially for LLMLexicalSimplifier.")

        self.model = model
        self.tokenizer = tokenizer
        self.pattern = pattern
        self.exemplars = exemplars

        if mask_token is not None:
            self.mask_token = mask_token
            print(f'Using mask token: "{mask_token}".')
        else:
            print('No mask token provided, using default mask token "[MASK]".')

    def set_model(self, model):
        self.model = model

    def set_tokenizer(self, tokenizer):
        self.tokenizer = tokenizer

    def set_pattern(self, pattern):
        self.pattern = pattern

    def set_exemplars(self, exemplars):
        self.exemplars = exemplars

    def apply_pattern_to(self, original_sentence: str, sentence_with_complex_word_masked: str) -> str:
        """
        Applies the currently configured pattern to inject a prompt between the original sentence and the sentence with
        the complex word masked.

        Returns:
            The string generated by applying the pattern to the passed args.

        Raises:
            ValueError: If the pattern is not set when called.
        """
        if self.pattern is None or self.pattern == "":
            raise ValueError("Please provide a pattern for this LexicalSimplifier.\n"
                             "A pattern should be a format string that can take at least one argument.")

        return self.pattern.format(original_sentence=original_sentence,
                                   sentence_with_complex_word_masked=sentence_with_complex_word_masked)

    @abc.abstractmethod
    def generate_substitutions_for(self, complex_word: str, original_sentence: str) -> List[str]:
        """
        Generates a list of substitutions via the model predictions for the given complex word in the context of the sentence.

        The input sentence specified by the original_sentence parameter should contain the complex word to be simplified and
        might need require further preprocessing (e.g. tokenization, masking) before being passed to the model.

        Args:
            complex_word: The complex word to be simplified. This is given in our case, we do not tackle complex word identification.
            original_sentence: The sentence containing the complex word.

        Returns:
            A list of possible substitutions for the complex word.
        """
        raise NotImplementedError("Please implement this method in the subclass.")
